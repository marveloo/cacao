#!/bin/sh

PROGRAM_NAME=${0##*/}
CA_NAME="Cacao CA"
CA_PATH=/etc/ssl/private/Cacao_CA.pem
CA_CERT_INSTALL_PATH=/usr/local/share/ca-certificates/Cacao_CA.crt
LEAF_DIR=/etc/ssl/private

help()
{
    echo "\
Usage: $PROGRAM_NAME [--] <domain-name>...
       $PROGRAM_NAME [-r] [-i] [-e <file-path>]
       $PROGRAM_NAME --help

This tool operates an autogenerated $CA_NAME to generate a TLS server
certificate and its corresponding private key for the specified list of
domain names. As a result, a compound certificate and key file will be
created in $LEAF_DIR directory. The name of the created file
matches that of the first <domain-name> specified on the command line plus
the '.pem' extension. If the file already exists, it will be overwritten.

Options:
   -r   regenerate $CA_NAME
   -i   install the current $CA_NAME certificate into the OS trust store
   -e   export the current $CA_NAME certificate to a file;
        when <file-path> is '-', write to standard output

Examples:
   Generate certificate and key file for example.com and *.example.com:
       $PROGRAM_NAME example.com \\*.example.com

   Regenerate $CA_NAME and (re)install its certificate into the OS trust store:
       $PROGRAM_NAME -ri

   Export $CA_NAME certificate as $PROGRAM_NAME.crt in the current directory:
       $PROGRAM_NAME -e $PROGRAM_NAME.crt
    "
}

subject_alt_name()
{
	local subject_alt_name="DNS:$1"
	shift

	for domain_name in "$@"; do
		subject_alt_name="$subject_alt_name,DNS:$domain_name"
	done

	echo "$subject_alt_name"
}

gen_ca()
(
    umask 077

    openssl req -config "" -x509 -noenc \
        > "$CA_PATH" \
        -subj "/CN=$CA_NAME" \
        -addext "basicConstraints=critical,CA:true,pathlen:0" \
        -addext "keyUsage=critical,keyCertSign" \
        -days 5000 \
        || return

    echo "$CA_NAME has been generated." >&2
)

gen_leaf()
(
    umask 077

    leaf_name=$1
    leaf_path="$LEAF_DIR/$leaf_name.pem"

    # TLS server certificates must have a validity period of 825 days
    # or fewer on iOS and macOS: https://support.apple.com/en-us/HT210176
    openssl req -config "" -x509 -noenc \
        -CA "$CA_PATH" > "$leaf_path" \
        -subj "/CN=$leaf_name" \
        -addext "basicConstraints=critical,CA:false" \
        -addext "keyUsage=critical,digitalSignature,keyEncipherment" \
        -addext "extendedKeyUsage=serverAuth,clientAuth" \
        -addext "subjectAltName=$(subject_alt_name "$@")" \
        -days 825 \
        || return

    echo "Certificate and its corresponding private key have been generated in $leaf_path" >&2
)

export_ca_cert()
{
    openssl x509 -in "$CA_PATH" -out "$1"
}

install_ca_cert()
{
    export_ca_cert "$CA_CERT_INSTALL_PATH" || return
    update-ca-certificates || return

    echo "$CA_NAME certificate has been installed into the system trust store." >&2
}

# # # # # Parse options # # # # #

show_help=false
regenerate_ca=false
install_ca_cert=false
export_ca_cert=false; ca_cert_export_path=
has_flags=false

while getopts rie:-: flag
do
    [ "$flag" = - ] && flag="--$OPTARG" || flag="-$flag"

    case "$flag" in
        --help )
            show_help=true ;;
        -r )
            regenerate_ca=true ;;
        -i )
            install_ca_cert=true ;;
        -e )
            export_ca_cert=true
            ca_cert_export_path=$OPTARG ;;
        --* )
            echo "Illegal option $flag" >&2; exit 1 ;;
        -\? )
            exit 1
    esac

    has_flags=true
done

shift $((OPTIND - 1))

# # # # # # # Main # # # # # # #

if ! $has_flags && [ $# -eq 0 ]; then
    help; exit 1
fi

if $show_help; then
    help; exit 0
fi

if $regenerate_ca || ! [ -f "$CA_PATH" ]; then
    gen_ca || exit
fi

if $install_ca_cert; then
    install_ca_cert || exit
fi

if $export_ca_cert; then
    export_ca_cert "$ca_cert_export_path" || exit
fi

if ! $has_flags && [ $# -gt 0 ]; then
    gen_leaf "$@"
fi