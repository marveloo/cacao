#!/bin/sh

PROGRAM_NAME=${0##*/}
CA_NAME="Cacao CA"
CA_PATH=/etc/ssl/private/Cacao_CA.pem
CA_CERT_INSTALL_PATH=/usr/local/share/ca-certificates/Cacao_CA.crt
LEAF_DIR=/etc/ssl/private

help()
{
    echo "\
Usage: $PROGRAM_NAME [--] <domain-name>...
       $PROGRAM_NAME [-u|--untrust] [--regenerate] [-t|--trust] [-p|--print]
       $PROGRAM_NAME --help

This tool operates an autogenerated $CA_NAME to generate a TLS server
certificate and its corresponding private key for the specified list of
domain names or IP addresses. As a result, a combined certificate and 
key file will be created in $LEAF_DIR directory. The name of 
the created file matches that of the first <domain-name> specified on 
the command line plus the '.pem' extension. If the file already exists, 
it will be refreshed with a new certificate and key pair.

Options:
   --regenerate   regenerate $CA_NAME
   -t, --trust    add $CA_NAME to the system's trust store
   -u, --untrust  remove $CA_NAME from the system's trust store
   -p, --print    print the $CA_NAME certificate

Examples:
   Generate a certificate and key file for example.com and *.example.com:
       $PROGRAM_NAME example.com \\*.example.com

   Regenerate the $CA_NAME certificate and add it to the system trust store:
       $PROGRAM_NAME --regenerate --trust

   Export the $CA_NAME certificate as $PROGRAM_NAME.crt:
       $PROGRAM_NAME -p > $PROGRAM_NAME.crt
    "
}

subject_alt_name()
(
    subject_alt_name=
    delimiter=

    for id in "$@"; do
        # DNS names cannot consist entirely of numbers and dots or contain colons
        expr "$id" : '[0-9.]*$\|.*:' >/dev/null && type=IP || type=DNS
        subject_alt_name=$subject_alt_name$delimiter$type:$id
        delimiter=,
    done

    printf %s "$subject_alt_name"
)

gen_ca()
(
    umask 077

    [ -f "$CA_PATH" ] && regenerate=true || regenerate=false

    [ "$regenerate" = true ] \
        && echo "Regenerating $CA_NAME" \
        || echo "Generating $CA_NAME..."

    # use -config "" to ensure no default configuration file is loaded
    cert=$(openssl req -config "" -x509 -noenc \
        -subj "/CN=$CA_NAME" \
        -addext "basicConstraints=critical,CA:true,pathlen:0" \
        -addext "keyUsage=critical,keyCertSign" \
        -days 5000
    ) || return 1

    printf '%s\n' "$cert" > "$CA_PATH" || return 1

    [ "$regenerate" = true ] \
        && echo "$CA_NAME regenerated." \
        || echo "$CA_NAME generated and ready for use."
)

gen_leaf()
(
    umask 077

    leaf_name=$1
    leaf_path="$LEAF_DIR/$leaf_name.pem"

    echo "Generating certificate..."

    # TLS server certificates must have a validity period of 825 days
    # or fewer on iOS and macOS: https://support.apple.com/en-us/HT210176

    # use -config "" to ensure no default configuration file is loaded
    cert=$(openssl req -config "" -x509 -noenc \
        -CA "$CA_PATH" \
        -subj "/CN=$leaf_name" \
        -addext "basicConstraints=critical,CA:false" \
        -addext "keyUsage=critical,digitalSignature,keyEncipherment" \
        -addext "extendedKeyUsage=serverAuth,clientAuth" \
        -addext "subjectAltName=$(subject_alt_name "$@")" \
        -days 825
    ) || return 1

    printf '%s\n' "$cert" > "$leaf_path" || return 1

    echo "Certificate and private key generated: $leaf_path"
)

print_ca_cert()
{
    openssl x509 -in "$CA_PATH" || return 1
}

update_system_trust_store()
(
    # use `--fresh` and hide confusing output messages on success 
    # to work around bugs in `update-ca-certificates`
    if ! output=$(update-ca-certificates --fresh 2>&1); then
        printf '%s\n' "$output" >&2
        return 1
    fi
)

untrust_ca_cert()
{
    echo "Untrusting $CA_NAME..."

    rm -- "$CA_CERT_INSTALL_PATH" || true
    update_system_trust_store || return 1

    echo "$CA_NAME removed from system trust store."
}

trust_ca_cert()
(
    echo "Trusting $CA_NAME..."

    cert=$(print_ca_cert) || return 1
    printf '%s\n' "$cert" > "$CA_CERT_INSTALL_PATH" || return 1    
    update_system_trust_store || return 1

    echo "$CA_NAME added to system trust store."
)

# # # # # Parse options # # # # #

show_help=false
regenerate_ca=false
trust_ca_cert=false
untrust_ca_cert=false
print_ca_cert=false
has_flags=false

while getopts tup-: flag
do
    [ "$flag" = - ] && flag="--$OPTARG" || flag="-$flag"

    case "$flag" in
        --help )
            show_help=true ;;
        --regenerate )
            regenerate_ca=true ;;
        -t | --trust )
            trust_ca_cert=true ;;
        -u | --untrust )
            untrust_ca_cert=true ;;
        -p | --print )
            print_ca_cert=true ;;
        --* )
            echo "Illegal option $flag" >&2; exit 1 ;;
        -\? )
            exit 1
    esac

    has_flags=true
done

shift $((OPTIND - 1))

# # # # # # # Main # # # # # # #

if [ "$has_flags" = false ] && [ $# -eq 0 ]; then
    help >&2; exit 1
fi

if [ "$show_help" = true ]; then
    help; exit 0
fi

if [ "$untrust_ca_cert" = true ]; then
    untrust_ca_cert || exit
fi

# generate only if CA file is accessible but does not exist
# or if explicitly requested
if 
    [ -x "$(dirname -- "$CA_PATH")" ] && ! [ -f "$CA_PATH" ] || 
    [ "$regenerate_ca" = true ]
then
    gen_ca || exit
fi

if [ "$trust_ca_cert" = true ]; then
    trust_ca_cert || exit
fi

if [ "$print_ca_cert" = true ]; then
    print_ca_cert || exit
fi

if [ "$has_flags" = false ] && [ $# -gt 0 ]; then
    gen_leaf "$@" || exit
fi
