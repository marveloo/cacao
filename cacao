#!/bin/sh

PROGRAM_NAME=${0##*/}
CA_NAME="Cacao CA"
CA_NAME_SANITISED="Cacao_CA"
CA_PATH=/etc/ssl/private/Cacao_CA.pem
LEAF_DIR=/etc/ssl/private

help()
{
    echo "\
Usage: $PROGRAM_NAME [--] <domain-name>...
       $PROGRAM_NAME --trust[=<store>]
       $PROGRAM_NAME --untrust[=<store>]
       $PROGRAM_NAME --ca-cert
       $PROGRAM_NAME --regenerate

This tool operates an autogenerated $CA_NAME to generate a TLS server
certificate and its corresponding private key for the specified list of
domain names or IP addresses. As a result, a combined certificate and 
key file will be created in $LEAF_DIR directory. The name of 
the created file matches that of the first <domain-name> specified on 
the command line plus the '.pem' extension. If the file already exists,
it will be renewed with a new certificate and key pair, including 
updated domain names and extended validity.

Options:
   --trust[=<store>]    add $CA_NAME to the system's trust store
   --untrust[=<store>]  remove $CA_NAME from the system's trust store
   --ca-cert            print the $CA_NAME certificate
   --regenerate         regenerate $CA_NAME

Examples:
   Generate a certificate for example.com and its subdomains:
       $PROGRAM_NAME \"example.com\" \"*.example.com\"

   Generate a certificate for localhost and its IP-based alternatives:
       $PROGRAM_NAME localhost 127.0.0.1 ::1

   Regenerate $CA_NAME and add it to the system trust store:
       $PROGRAM_NAME --regenerate --trust

   Export the $CA_NAME certificate as $PROGRAM_NAME.crt:
       $PROGRAM_NAME --ca-cert > $PROGRAM_NAME.crt
    "
}

subject_alt_name()
(
    subject_alt_name=
    delimiter=

    for id in "$@"; do
        # DNS names cannot consist entirely of numbers and dots or contain colons
        expr "$id" : '[0-9.]*$\|.*:' >/dev/null && type=IP || type=DNS
        subject_alt_name=$subject_alt_name$delimiter$type:$id
        delimiter=,
    done

    printf %s "$subject_alt_name"
)

gen_ca()
(
    # use -config "" to ensure no default configuration file is loaded
    cert=$(openssl req -config "" -x509 -noenc \
        -subj "/CN=$CA_NAME" \
        -addext "basicConstraints=critical,CA:true,pathlen:0" \
        -addext "keyUsage=critical,keyCertSign" \
        -days 5000
    ) || return 1

    umask 077
    printf '%s\n' "$cert" > "$CA_PATH" || return 1
)

gen_leaf()
(
    leaf_name=$1
    leaf_path=$2
    shift 2

    if ca_missing; then
        gen_ca || return 1
    fi

    # TLS server certificates must have a validity period of 825 days
    # or fewer on iOS and macOS: https://support.apple.com/en-us/HT210176

    # use -config "" to ensure no default configuration file is loaded
    cert=$(openssl req -config "" -x509 -noenc \
        -CA "$CA_PATH" \
        -subj "/CN=$leaf_name" \
        -addext "basicConstraints=critical,CA:false" \
        -addext "keyUsage=critical,digitalSignature,keyEncipherment" \
        -addext "extendedKeyUsage=serverAuth,clientAuth" \
        -addext "subjectAltName=$(subject_alt_name "$@")" \
        -days 825
    ) || return 1

    umask 077
    printf '%s\n' "$cert" > "$leaf_path" || return 1

    echo "Certificate and private key generated: $leaf_path"
)

print_ca_cert()
{
    if ca_missing; then
        gen_ca >&2 || return 1
    fi

    openssl x509 -in "$CA_PATH" || return 1
}

# Executes a specified command silently (i.e., without output),
# unless an error occursâ€”in which case, all output is displayed
exec_silent()
(
    if ! output=$("$@" 2>&1); then
        printf '%s\n' "$output" >&2
        return 1
    fi
)

ca_missing()
(
    ca_dir=$(dirname -- "$CA_PATH")
    [ -d "$ca_dir" ] && [ -x "$ca_dir" ] && ! [ -f "$CA_PATH" ]
)

ca_cert_fingerprint()
(
    fingerprint=$(openssl x509 -in "$CA_PATH" -noout -fingerprint) || return 1
    printf %s "$(printf %s "${fingerprint#*=}" | tr -d :)"
)

# This is a certutil.exe wrapper that iterates over parent processes and 
# finds PATH within which certutil.exe can be launched. This allows us 
# to work around WSL interoperability issues caused by restrictions on 
# environment variables under `sudo`.
certutil_exe()
(
    if certutil_exe=$(command -v certutil.exe); then
        "$certutil_exe" "$@" </dev/null || return 1
        return 0
    fi

    pid=$$

    while [ "$pid" -ne 1 ]; do

        pid=$(ps -o ppid= -p "$pid" 2>/dev/null) || pid=1
        pid=$(echo "$pid" | tr -d ' ')

        if envars=$(tr '\0' '\n' 2>/dev/null </proc/"$pid"/environ); then
            path=$(printf %s "$envars" | sed -n '/^PATH=/ { s/^PATH=//; p; q; }');

            if certutil_exe=$(PATH=$path command -v certutil.exe); then
                "$certutil_exe" "$@" </dev/null || return 1
                return 0
            fi
        fi        

    done

    echo "certutil.exe not found" >&2
    return 1
)

system_trust_store()
(
    cmd=$1

    if [ -d "/etc/pki/ca-trust/source/anchors" ]; then
        trust_file="/etc/pki/ca-trust/source/anchors/%s.pem"
        trust_cmd="update-ca-trust extract"
    elif [ -d "/usr/local/share/ca-certificates" ]; then
        trust_file="/usr/local/share/ca-certificates/%s.crt"
        trust_cmd="update-ca-certificates --fresh"
    elif [ -d "/etc/ca-certificates/trust-source/anchors" ]; then
        trust_file="/etc/ca-certificates/trust-source/anchors/%s.crt"
        trust_cmd="trust extract-compat"
    elif [ -d "/usr/share/pki/trust/anchors" ]; then
        trust_file="/usr/share/pki/trust/anchors/%s.pem"
        trust_cmd="update-ca-certificates"
    else
        echo "No supported system trust store found." >&2
        echo "Use \`$PROGRAM_NAME --ca-cert\` to export the $CA_NAME certificate for manual installation." >&2
        return 1
    fi

    if [ "$cmd" = add-ca-cert ] && ca_missing; then
        gen_ca || return 1
    fi

    fingerprint=$(ca_cert_fingerprint) || return 1
    # shellcheck disable=SC2059
    trust_file=$(printf -- "$trust_file" "${CA_NAME_SANITISED}_$fingerprint")

    if [ "$cmd" = add-ca-cert ]; then

        cert=$(openssl x509 -in "$CA_PATH") || return 1
        printf '%s\n' "$cert" > "$trust_file" || return 1

        # shellcheck disable=SC2086
        exec_silent $trust_cmd || return 1

        echo "$CA_NAME added to system trust store."

    elif [ "$cmd" = remove-ca-cert ]; then

        rm -f -- "$trust_file" || return 1

        # shellcheck disable=SC2086
        exec_silent $trust_cmd || return 1

        echo "$CA_NAME removed from system trust store."

    fi
)

wsl_trust_store()
(
    cmd=$1

    if ! [ -x "$(command -v wslpath)" ]; then
        echo "$PROGRAM_NAME requires Windows 10, version 1803 or newer." >&2
        return 1
    fi

    if [ "$cmd" = add-ca-cert ]; then

        if ca_missing; then
            gen_ca || return 1
        fi

        cert=$(openssl x509 -in "$CA_PATH") || return 1
        cert_path=$(mktemp) && trap 'rm -- "$cert_path"' EXIT || return 1
        chmod a+r "$cert_path" || return 1
        printf '%s\n' "$cert" > "$cert_path" || return 1

        cert_wslpath=$(wslpath -w "$cert_path") || return 1
        exec_silent certutil_exe -user -addstore Root "$cert_wslpath" || return 1

        echo "$CA_NAME added to Windows Certificate Store."

    elif [ "$cmd" = remove-ca-cert ]; then

        fingerprint=$(ca_cert_fingerprint) || return 1
        exec_silent certutil_exe -user -delstore Root "$fingerprint" || return 1

        echo "$CA_NAME removed from Windows Certificate Store."

    fi
)

# # # # # Parse options # # # # #

show_help=false
regenerate_ca=false
trust_ca_cert_on_system=false
untrust_ca_cert_on_system=false
trust_ca_cert_on_wsl=false
untrust_ca_cert_on_wsl=false
print_ca_cert=false
opt_count=0

while getopts h-: opt
do
    [ "$opt" = - ] && opt="--$OPTARG" || opt="-$opt"

    case "$opt" in
        --help | -h )
            show_help=true ;;
        --regenerate )
            regenerate_ca=true ;;
        --trust | --trust=system )
            trust_ca_cert_on_system=true ;;
        --untrust | --untrust=system )
            untrust_ca_cert_on_system=true ;;
        --trust=wsl )
            trust_ca_cert_on_wsl=true ;;
        --untrust=wsl )
            untrust_ca_cert_on_wsl=true ;;
        --ca-cert )
            print_ca_cert=true ;;
        --* )
            echo "Illegal option $opt" >&2; exit 1 ;;
        -\? )
            exit 1
    esac

    opt_count=$((opt_count + 1))
done

shift $((OPTIND - 1))

# # # # # # # Main # # # # # # #

if [ "$opt_count" -eq 0 ] && [ $# -gt 0 ]; then
    leaf_name=$1
    leaf_path="$LEAF_DIR/$leaf_name.pem"
    gen_leaf "$leaf_name" "$leaf_path" "$@"; exit
fi

if [ "$trust_ca_cert_on_system" = true ]; then
    system_trust_store add-ca-cert; exit
fi

if [ "$trust_ca_cert_on_wsl" = true ]; then
    wsl_trust_store add-ca-cert; exit
fi

if [ "$untrust_ca_cert_on_system" = true ]; then
    system_trust_store remove-ca-cert; exit
fi

if [ "$untrust_ca_cert_on_wsl" = true ]; then    
    wsl_trust_store remove-ca-cert; exit
fi

if [ "$print_ca_cert" = true ]; then
    print_ca_cert; exit
fi

if [ "$regenerate_ca" = true ]; then
    gen_ca || exit
    echo "$CA_NAME regenerated."
    exit 0
fi

if [ "$show_help" = true ]; then
    help
    exit 0
fi

if [ "$opt_count" -eq 0 ] && [ $# -eq 0 ]; then
    help >&2
    exit 1
fi
